name: Deploy Lambda

on:
  push:
    branches:
      - master
    paths:
      - 'src/**'
      - 'infra/**'
      - '.github/workflows/deploy-lambda.yml'

jobs:
  deploy-lambda:
    runs-on: ubuntu-latest

    steps:
      - name:  Checkout repository
        uses: actions/checkout@v3

      - name:  Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name:  Install dependencies
        working-directory: ./src
        run: npm ci

      - name: ðŸ› ï¸Build NestJS app
        working-directory: ./src
        run: npm run build

      - name:  Package Lambda as ZIP
        working-directory: ./src
        run: |
          npm prune --production
          zip -r ../infra/lambda/backend-api.zip dist node_modules package.json -x "**/*.map" "**/*.d.ts" "**/test/**"

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      - name:  Terraform Lambda Init & Apply
        working-directory: ./infra/lambda
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          terraform init
          terraform apply -auto-approve -var-file=dev.tfvars

      - name:  Terraform EC2 Init & Apply
        working-directory: ./infra/ec2
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          terraform init
          terraform apply -auto-approve -var-file=dev.tfvars

      - name:  Get EC2 Name Tag and S3 Bucket from Terraform
        id: get-vars
        working-directory: ./infra/ec2
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          echo "ec2_name=$(terraform output -raw ec2_instance_name)" >> $GITHUB_OUTPUT
          echo "sql_backup_bucket=$(terraform output -raw sql_backup_bucket)" >> $GITHUB_OUTPUT
          echo "EC2_NAME_TAG=$(terraform output -raw ec2_instance_name)" >> $GITHUB_ENV
          echo "SQL_BACKUP_BUCKET=$(terraform output -raw sql_backup_bucket)" >> $GITHUB_ENV

      - name:  Check & Install AWS CLI if not present
        run: |
          if ! command -v aws &> /dev/null; then
            echo "AWS CLI not found. Installing..."
            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
            unzip -q awscliv2.zip
            sudo ./aws/install
          else
            echo " AWS CLI already installed: $(aws --version)"
          fi

      - name:  Wait for EC2 to register in SSM
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          EC2_NAME_TAG: ${{ env.EC2_NAME_TAG }}
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=$EC2_NAME_TAG" \
            --query "Reservations[*].Instances[*].InstanceId" \
            --output text --region us-east-1)

          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV

          echo " Checking SSM registration for: $INSTANCE_ID"
          for i in {1..10}; do
            CHECK=$(aws ssm describe-instance-information \
              --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
              --region us-east-1 \
              --query "InstanceInformationList[0].InstanceId" \
              --output text 2>/dev/null)

            if [[ "$CHECK" == "$INSTANCE_ID" ]]; then
              echo " EC2 registered with SSM."
              exit 0
            fi

            echo " Waiting for SSM... attempt $i"
            sleep 15
          done

          echo " EC2 instance not registered in SSM."
          exit 1

      - name: ðŸ› ï¸nstall PostgreSQL 15 via SSM
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Install PostgreSQL 15" \
            --parameters 'commands=[
              "export DEBIAN_FRONTEND=noninteractive",
              "set -eux",
              "if ! command -v psql || ! psql --version | grep -q '\''15'\''; then",
              "apt-get update -y",
              "apt-get install -y curl gnupg2 lsb-release ca-certificates sudo software-properties-common",
              "curl -fsSL https://www.postgresql.org/media/keys/ACCC4CF8.asc | gpg --batch --yes --dearmor -o /usr/share/keyrings/postgresql.gpg",
              "echo \"deb [signed-by=/usr/share/keyrings/postgresql.gpg] http://apt.postgresql.org/pub/repos/apt noble-pgdg main\" > /etc/apt/sources.list.d/pgdg.list",
              "apt-get update -y",
              "apt-get install -y postgresql-15 postgresql-client-15",
              "systemctl enable postgresql",
              "systemctl start postgresql",
              "echo \"host all all 0.0.0.0/0 md5\" >> /etc/postgresql/15/main/pg_hba.conf",
              "sudo -u postgres psql -c \"ALTER SYSTEM SET listen_addresses = '*'\"",
              "systemctl restart postgresql"
              "else",
              "  echo 'PostgreSQL 15 already installed. Skipping.'",
              "fi"
            ]' \
            --region us-east-1 \
            --output text

      - name: Create DB & Import SQL Backup via SSM
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          EC2_NAME_TAG: ${{ env.EC2_NAME_TAG }}
          SQL_BACKUP_BUCKET: ${{ env.SQL_BACKUP_BUCKET }}
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=$EC2_NAME_TAG" \
            --query "Reservations[*].Instances[*].InstanceId" \
            --output text --region us-east-1)

          aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Create DB and Import SQL Backup" \
            --parameters 'commands=[
              "bash -c '\''set -eux; \
                sudo -u postgres psql -tc \"SELECT 1 FROM pg_database WHERE datname = '\''license'\''\" | grep -q 1 || sudo -u postgres psql -c \"CREATE DATABASE license\"; \
                sudo -u postgres psql -d license -tc \"SELECT 1 FROM information_schema.tables WHERE table_name = '\''users'\'';\" > /dev/null 2>&1; \
                if [ $? -ne 0 ]; then \
                  echo \"Restoring DB from S3 backup...\"; \
                  aws s3 cp s3://'"$SQL_BACKUP_BUCKET"'/back-up-db/license_backup.sql /tmp/license_backup.sql; \
                  sudo -u postgres psql -d license -f /tmp/license_backup.sql; \
                else \
                 echo \"Database already initialized. Skipping restore.\"; \
                fi'\''"
            ]' \
            --region us-east-1 \
            --output text

      - name:  Terraform REST API Init & Apply
        working-directory: ./infra/api
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          terraform init
          terraform apply -auto-approve -var-file=dev.tfvars
